package main

import (
	"bytes"
	"crypto/md5"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"labix.org/v2/mgo"
	"labix.org/v2/mgo/bson"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

type Source struct {
	Id        bson.ObjectId     `bson:"_id"`
	ResultIds []string          `bson:"results"`
	Files     map[string]string `bson:"files"`
	Arch      string            `bson:"arch"`
	Args      string            `bson:"args,omitempty"`
}

func main() {
	flag.Parse()
	startTime := time.Now()
	root, _ := os.Getwd()

	var gccOut, gccErr bytes.Buffer
	gccCmd := exec.Command("gcc", flag.Args()...)
	gccCmd.Stderr = &gccErr
	gccCmd.Stdout = &gccOut

	s := &Source{
		Arch:  runtime.GOOS + "-" + runtime.GOARCH,
		Args:  strings.Join(flag.Args(), " "),
		Files: map[string]string{},
	}

	if err := filepath.Walk(root, func(path string, f os.FileInfo, err error) error {
		relPath, _ := filepath.Rel(root, path)
		// ignore hidden directories and .
		if relPath == "." || strings.Contains(relPath, "/.") {
			return nil
		}

		content, _ := ioutil.ReadFile(path)
		s.Files[strings.Replace(relPath, ".", "_", -1)] = fmt.Sprintf("%x", md5.Sum(content))
		return nil
	}); err != nil {
		fmt.Println("Failed:", err)
		return
	}

	session, err := mgo.Dial("localhost")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer session.Close()

	db := session.DB("bcc-test")
	c := db.C("sources")
	fs := db.GridFS("fs")
	err = c.Find(bson.M{"files": s.Files}).One(&s)

	if err != nil && err.Error() == "not found" {
		fmt.Println("Result not found in cache. Running gcc (may take a while)...")
		err = gccCmd.Run()
		fmt.Println(gccOut.String())
		if err != nil {
			fmt.Println("running gcc failed:", err, gccErr.String())
			return
		}
		fmt.Println("gcc has finished. Adding result in cache.")

		sourceId := bson.NewObjectId()
		s.Id = sourceId

		var files []string
		// insert files that have been created since start
		if err = filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
			relPath, _ := filepath.Rel(root, path)
			// ignore hidden directories and .
			if relPath == "." || strings.Contains(relPath, "/.") {
				return nil
			}

			if info.ModTime().Unix() >= startTime.Unix() { // .After isn't granular enough
				fmt.Println("- " + relPath + " has been generated by gcc and is being added to cache.")
				file, err := fs.Create(sourceId.Hex() + ":" + relPath)
				if err != nil {
					fmt.Println("file creation failed")
					return err
				}
				content, err := os.Open(path)
				if err != nil {
					fmt.Println("reading file failed")
					return err
				}
				defer content.Close()

				if _, err = io.Copy(file, content); err != nil {
					fmt.Println("io copy failed")
					return err
				}
				if err = file.Close(); err != nil {
					fmt.Println("file.Close failed")
					return err
				}

				fmt.Println("File ID", file.Id().(bson.ObjectId))
				files = append(files, file.Id().(bson.ObjectId).Hex())

			}
			return nil
		}); err != nil {
			fmt.Println("Failed:", err)
			return
		}

		// insert
		s.ResultIds = files
		if err = c.Insert(s); err != nil {
			fmt.Println(err)
		}
		return
	} else if err != nil {
		fmt.Println(err)
		return
	} else {
		fmt.Println("Found! Writing files from cache instead of running gcc...")
		resultId := s.Id.Hex()
		objectIds := []bson.ObjectId{}
		for _, id := range s.ResultIds {
			objectIds = append(objectIds, bson.ObjectIdHex(id))
		}

		targetResults := []bson.M{}
		if err = fs.Find(bson.M{"_id": bson.M{"$in": objectIds}}).All(&targetResults); err != nil {
			fmt.Println(err)
			return
		}
		for _, f := range targetResults {
			file, err := fs.OpenId(f["_id"])
			if err != nil {
				fmt.Println(err)
				return
			}

			outPath := strings.Replace(f["filename"].(string), resultId+":", "", -1)
			outfile, err := os.Create(outPath)
			if err != nil {
				fmt.Println(err)
				return
			}

			if _, err = io.Copy(outfile, file); err != nil {
				fmt.Println(err)
				return
			}

			if err = file.Close(); err != nil {
				fmt.Println(err)
				return
			}

			if err = exec.Command("chmod", "+x", outPath).Run(); err != nil {
				fmt.Println(err)
				return
			}
			fmt.Println("Finished writing " + outPath + ".")
		}
	}
}
